4-1.:于python有关的三个对象属性是，对象身份，对象值和对象类型，对象身份相当于
这个值，对象存在计算机当中的某个地点的标记号，是计算机中唯一的身份识别，也相当于
个人的身份识别，只存在唯一性，除非这个对象不存在引用，或者被内存机制消除，那么
这个唯一性就一直现在，对象一直存在被标记的身份内存序列位置，
第二个就是对象的值，在被创建出赋予对象的值，在调用对象的时候相当于调用了这种之前
被创建出来的值，第三个就是对象的类型，在对象被创建出来的时候开始，就已经被定义
是何种类型，这种类型可以用type()内置函数查看，有整形，浮点型，字符串，复杂性，
还有长整形依然算整形，元祖，列表，字典，值得类型，在一定程度上决定了到底是做啥的
该如何去做，
4-2:类型，在python中每个值的类型不同可用type()查看，这些类型那些是可以更改的
那些是不可更改的，在python值当中，可更改的值有列表，字典，元祖是被规定不可更改的
数字也是不可更改的，实际上你以为数字是被更改的其实只不过，数字重新创建，又重新
赋值了而已，在重新创建和赋值的时候，之前的旧的地址和对象值已经被消除了，同时
表示没有人引用这个对象和值了，被内存机制处理，分配了一个新的对象和值地址，准确
来说并不是更改，是重新赋值，字符串也是不可更改的，在进行赋值的时候，字符串中间
的字符已经是固定的了，
4-3：在python当中有些很多值的类型，这些类型当中又分出很多小类型，这些小类型又
归到一个类型当中，在这些类型当中，其中访问顺序是怎么访问的，整数类型，里面访问
数值的方法都是按顺序访问的一个一个的读取，小数点也是数值类型，同样按照顺序访问的
方法，其中字符串，相当于文本访问顺序同样是按照顺序访问，在列表和元祖当中，访问
是按照，列表的索引和元祖的索引，切片进行访问，这也都是按照顺序访问，除了数值和
字典，其他的方法都是按照顺序访问不同类型当中的值，其中字典比较特殊，存在键值关系
访问是按照映射关系哈希键和值的关系进行访问，键和值没有顺序关系，如果访问，讲进行
对键的访问从而获得相对的映射值，数值一般都是单一的所以访问的时候将直接访问里面的数值，是直接性质的，像字符串，列表，元祖，之类的，都有索引，顺序，字符串是文本形式所以也是顺序访问关系
4-4:内建函数type()用来确定每个对象的类型，是整形还是浮点型，还是字符串，还是字典
还是列表，还是元祖，还是类的类型，还是类实例化的类型，不管是上面对象，只要放入
type()内建函数当中审查基本都会存在，只要这个对象在python当中合法，内建函数返回的对象是什么，内置函数返回的对象是type()对象是type类型对象，
4-5:str()和repr()，都是字符串之间并没有上面不同，str字符串对用户比较友好，repr对
机器编译器，比较友好，其中repr()等价于‘’双个单引号，组成的字符串
4-6:type(a) == type(b) 和type(a) is type(b)之间的不同仅仅在于他们的比较方法，
但是比较的性质是一样的，仅仅判断他们的值是否是同一个类型，可能会因为is的方法进行
id判断，但是内置函数type()的判断方法不变，依然是比较是否是相同类型，不同的只有
比较的方法，比较的性质相同，为什么选择后者，除了容易写以外，应该就是比较的方法
吧，==只是进行单纯的值标记，而is是进行内存的标记，比较高效率？
函数isinstance()也可以进行对象类型比较，只不过需要提前输入想要比较的类型，以传递
参数的方式比较，比较的方法传递的参数，可以是用元祖进行没试过，它和type()内置函数的方式差不多都能起到相同的作用，查询对象的类型，
4-7:各种类型基本都明白，一些高级和不常用的类型目前还不明白，目前已知的类型有int float str list tuple dict这些类型，
4-8:列表和元祖之间的相同点是都可以存储不同类型的对象和数值，把他们放入列表或者元祖当中，不同的地方在于，列表当中的对象数值，可以使用不同的方法提取，删除，更新
叠加，变更，而元祖确是不行，元祖只能存储数据对象值，但是不能以其他方式修改，
4-9:这是因为和python的内存管理机制有关系，在进行数值赋值的时候python认为数值比较
小的会被经常调用，从而减少了缓存机制的时间，所以在进行is id()内置函数比较的时候，会存在内存地址相同的事情，而小数点的存储机制不同造成了python的高速存储，进行了
内存地址的不同更变，整形和字符串是不可变对象，所以python很高效的缓存他们，小数
确是不同，小数会被分配新的id身份地址
